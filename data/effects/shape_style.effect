// Applies SDF shape masking + border + drop shadow to an RGBA input.
//
// Shape types (shape_type):
//   0 = circle (inscribed)
//   1 = rectangle (full)
//   2 = rounded rectangle (full; uses corner_radius)
//   3 = square (inscribed; uses corner_radius)
//   4 = vertical rectangle (inscribed; 9:16 aspect; uses corner_radius)
//
// Inputs:
//   image            - composited camera texture
//
// Params (pixel units unless noted):
//   size             - render size in pixels (width, height)
//   shape_type       - int, see above
//   corner_radius    - rounded corner radius in px
//   feather          - edge AA / feather in px (>= 0; 1 is a good default)
//   border_thickness - border thickness in px
//   border_color     - RGBA
//   inset            - inner padding in px: (left, top, right, bottom)
//   shadow_offset    - shadow offset in px (x right, y down)
//   shadow_blur      - shadow softness in px
//   shadow_color     - RGBA

uniform float4x4 ViewProj;
uniform texture2d image;

uniform float2 size;
uniform float shape_type;
uniform float corner_radius;
uniform float feather;
uniform float border_thickness;
uniform float4 border_color;
uniform float4 inset;
uniform float4 frame_inset; // (left, top, right, bottom) in px; applied to Rectangle/Square
uniform float2 shadow_offset;
uniform float shadow_blur;
uniform float4 shadow_color;

sampler_state linear_clamp_sampler {
	Filter   = Linear;
	AddressU = Clamp;
	AddressV = Clamp;
};

struct VertData {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

struct VertOut {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

VertOut VSDefault(VertData v_in)
{
	VertOut v_out;
	v_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	v_out.uv  = v_in.uv;
	return v_out;
}

float sdCircle(float2 p, float r)
{
	return length(p) - r;
}

float sdBox(float2 p, float2 b)
{
	float2 d = abs(p) - b;
	return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

float sdRoundBox(float2 p, float2 b, float r)
{
	float2 q = abs(p) - (b - r);
	return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;
}

float ShapeSDF(float2 p, float2 half_size)
{
	// Inscribed radius for circle/square.
	float r = min(half_size.x, half_size.y);
	float r_scaled = r;

	// Default box size for rectangle/rounded rectangle is full.
	float2 box_half = half_size;

	// Vertical rectangle: inscribed 9:16.
	if (shape_type > 3.5) {
		const float ar = 9.0 / 16.0; // width / height
		float cur_ar = half_size.x / max(half_size.y, 0.001);
		if (cur_ar > ar) {
			// Too wide: limit width.
			box_half = float2(half_size.y * ar, half_size.y);
		} else {
			// Too tall: limit height.
			box_half = float2(half_size.x, half_size.x / ar);
		}
	}

	float rr_box = min(max(corner_radius, 0.0), min(box_half.x, box_half.y));
	float rr_square = min(max(corner_radius, 0.0), r_scaled);

	if (shape_type < 0.5)
		return sdCircle(p, r);
	if (shape_type > 2.5 && shape_type < 3.5)
		return sdRoundBox(p, float2(r_scaled, r_scaled), rr_square);
	if (shape_type > 1.5 && shape_type < 2.5)
		return sdRoundBox(p, box_half, rr_box);
	if (shape_type > 3.5)
		return sdRoundBox(p, box_half, rr_box);
	return sdBox(p, box_half);
}

float AlphaFromSDF(float dist, float aa)
{
	// dist < 0 inside.
	return smoothstep(aa * 0.5, -aa * 0.5, dist);
}

float4 OverPM(float4 dst, float4 src)
{
	// Premultiplied alpha "over": assumes src.rgb and dst.rgb are already multiplied by their alpha.
	return src + dst * (1.0 - src.a);
}

float4 PSShapeStyle(VertOut v_in) : TARGET
{
	float2 safe_size = max(size, float2(1.0, 1.0));
	float2 inner_size = safe_size - float2(inset.x + inset.z, inset.y + inset.w);
	inner_size = max(inner_size, float2(1.0, 1.0));

	// Frame crop (rectangle/square only). For other shapes, host passes zeros.
	float2 frame_size = safe_size - float2(frame_inset.x + frame_inset.z, frame_inset.y + frame_inset.w);
	frame_size = max(frame_size, float2(1.0, 1.0));
	float2 frame_half = frame_size * 0.5;

	// Shift center if crop is asymmetric.
	float2 frame_center_offset = float2((frame_inset.x - frame_inset.z) * 0.5, (frame_inset.y - frame_inset.w) * 0.5);

	float2 half_size = inner_size * 0.5;
	float2 p = (v_in.uv - 0.5) * safe_size - frame_center_offset;
	float2 uv_img = v_in.uv;

	// Apply crop sizing for rectangle/square types.
	if (shape_type > 0.5 && shape_type < 1.5) {
		half_size = frame_half;
	} else if (shape_type > 2.5 && shape_type < 3.5) {
		float r = min(frame_half.x, frame_half.y);
		half_size = float2(r, r);
	}

	float aa = max(feather, 0.001);
	float bt = max(border_thickness, 0.0);

	float dist = ShapeSDF(p, half_size);
	float shape_a = AlphaFromSDF(dist, aa);

	// Border ring (inside the shape).
	float outer_a = AlphaFromSDF(dist, aa);
	float inner_a = AlphaFromSDF(dist + bt, aa);
	float border_a = saturate(outer_a - inner_a);

	// Shadow: shifted copy of the shape, softened outside the edge.
	float2 sp = p - shadow_offset;
	float sdist = ShapeSDF(sp, half_size);
	float sblur = max(shadow_blur, 0.001);
	float shadow_a = saturate(1.0 - smoothstep(0.0, sblur, sdist));
	shadow_a *= (1.0 - shape_a);
	shadow_a *= shadow_color.a;

	float4 outc = float4(0.0, 0.0, 0.0, 0.0);

	// Shadow (behind).
	outc = OverPM(outc, float4(shadow_color.rgb * shadow_a, shadow_a));

	// Content (clipped by shape alpha).
	float4 img = image.Sample(linear_clamp_sampler, uv_img);
	float content_a = shape_a * img.a;
	outc = OverPM(outc, float4(img.rgb * content_a, content_a));

	// Border (on top).
	float b_a = border_a * border_color.a;
	outc = OverPM(outc, float4(border_color.rgb * b_a, b_a));

	return outc;
}

technique ShapeStyle
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = PSShapeStyle(v_in);
	}
}

// Compatibility alias (common convention in OBS effects).
technique Draw
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = PSShapeStyle(v_in);
	}
}
